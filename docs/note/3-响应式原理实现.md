# 响应式原理实现

昨天讲完响应式的基本原理，今天就动手做个简单的，然后顺便把Vue中的实现讲讲

## 手动造一个简单的试试水

我们先自己实现一个响应式的思路

- _init进行依赖收集
- defineReactive进行数据劫持函数定义
- 触发监听事件
- 派发更新

### HTML结构

下面先写一个简单的结构用于后面的说明：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>响应式实例</title>
</head>
<body>
    <button class="test-btn">Click</button>
    <p>You have clicked <span class='sum'>0</span> </p>

    <script src="./main.js"></script>
</body>
</html>
```

### main.js

js部分首先是_init函数

```js
function _init () {
    // 定义数据劫持
    observeObj(reactiveObj);
    
    // 添加监听事件
    let button = document.querySelector('.test-btn')
    button.addEventListener('click', () => {
        reactiveObj.clickSum += 1
    })
    
    // 模拟Dep.target，用于标明函数执行环境，介绍见Vue实现解析
    currentTarget = 'window'
    // 模拟Vue的更新
    fakeUpdateComponentFunc()
    // 恢复Dep.target
    currentTarget = ''
}
```

#### 数据劫持实现

对对象的属性进行遍历，通过Object.defineProperty进行劫持函数的编写

```js
function observeObj (reactiveObj) {
    for (let key in reactiveObj) {
        defineReactive(reactiveObj, key)
    }
}
function defineReactive (obj, key) {
    let val = obj[key]
    let dep = ''

    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () { },
        set: function reactiveSetter (newValue) {  }
    })
}
```

重点介绍下getter和setter函数

```js
Object.defineProperty(obj, key, {
    enumerable: true, // 可枚举
    configurable: true, // 可配置
    get: function reactiveGetter () {
        console.log('getter has been called')

        // 这里进行依赖收集
        // 判断当前的执行环境，将dep保存给setter更新时用
        if (currentTarget) {
            // dep.depend()
            console.log('===> dep collection done')
        }

        return val
    },
    set: function reactiveSetter (newValue) {
        console.log('setter has been called')

        if (newValue === val) {
            return
        }
        console.log('===> value has been set')
        val = newValue
        
        // 这里进行派发更新，其实notify就会执行updateComponent，这里做了省略
        // dep.notify()
        fakeUpdateComponentFunc()
    }
})
```

我们在来看看updateComponent函数，这里模拟了vue.$mount过程中执行的两个关键函数

```js
function fakeUpdateComponentFunc () {
    (function _render() {
        // do nothing...
    })(); // template/render func => vnode
    
    (function _update() {
        applyToDom('.sum', reactiveObj.clickSum)
    })() // vnode => dom
}
```

然后就完啦，一个简单的响应式系统就实现了233，可以运行下看看效果哈

## Vue中的响应式实现

看完上面的解释是不是感觉条理清晰很多呀，基本上Vue的实现思路即使如此，那么我们来看看源代码中的执行思路

### Watcher

### Dep

## 总结

讲完了响应式原理，我们再来看看组件化是怎么实现的


